\documentclass[12pt]{article}

%%\usepackage[margin = 1in]{geometry}

\usepackage{graphicx}              
\usepackage{fullpage}              
\usepackage{amsmath}               
\usepackage{amsfonts}              
\usepackage{amsthm}                
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{authblk}


\hypersetup{
	unicode=true,
	colorlinks=true,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black,
	pdfstartview={FitH},
}

% theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{example}[theorem]{Example}
\newtheorem*{remark}{Remark}
\newtheorem{note}[theorem]{Note}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\algsetup{linenodelimiter=.}





\newcommand{\wrt}{\vdash} 
\newcommand{\ang}[1]{\{#1\}}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\dual}[1]{\overline{#1}}
\newcommand{\mapsfrom}{\ensuremath{\reflectbox{$\mapsto$}}}
\newcommand{\tildO}{\tilde{O}}
% roman numerals
\newcommand{\romnum}[1]{\romannumeral #1}
\newcommand{\Romnum}[1]{\uppercase\expandafter{\romannumeral #1}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\comment}[2][Note]{\textcolor{green}{(#1): #2}}

\DeclareMathOperator{\fieldchar}{char} % characteristic of a field
\DeclareMathOperator{\End}{{\rm End}} % endomorphism ring
\DeclareMathOperator{\trace}{Tr} % finite field trace
\DeclareMathOperator{\gal}{{\rm Gal}} % Galois group
\DeclareMathOperator{\order}{ord} % order of an element
\DeclareMathOperator{\lcm}{lcm} % least common multiple
\DeclareMathOperator{\divisor}{div} % divisor on a curve
\DeclareMathOperator{\supp}{supp} % support of a divisor
\DeclareMathOperator{\norm}{N} % norm
\DeclareMathOperator{\Res}{Res}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\minpoly}{minpoly}
\DeclareMathOperator{\loglog}{loglog}
\DeclareMathOperator{\rev}{rev}

\def\Q{\ensuremath{\mathbb{Q}}}
\def\N{\ensuremath{\mathbb{N}}}
\def\R{\ensuremath{\mathbb{R}}}
\def\Z{\ensuremath{\mathbb{Z}}}
\def\F{\ensuremath{\mathbb{F}}}
% \def\H{\ensuremath{\mathbb{H}}}
\def\K{\ensuremath{\mathbb{K}}}
% \def\L{\ensuremath{\mathbb{L}}}
% \def\A{\ensuremath{\mathbb{A}}}
% \def\B{\ensuremath{\mathbb{B}}}
\def\MM{\ensuremath{\mathsf{M}}}
\def\MMM{\ensuremath{\mathsf{MM}}}
% \def\MC{\ensuremath{\mathsf{C}}}
% \def\PC{\ensuremath{\mathsf{PC}}}
% \def\II{\ensuremath{\mathsf{I}}}
% \def\QQ{\ensuremath{\mathsf{Q}}}
\def\CC{\ensuremath{\mathsf{C}}}
% \def\RR{\ensuremath{\mathsf{R}}}
% \def\AA{\ensuremath{\mathsf{A}}}
% \def\va{\ensuremath{\mathsf{a}}}
% \def\vy{\ensuremath{\mathsf{y}}}
% \def\vu{\ensuremath{\mathsf{u}}}
% \def\vb{\ensuremath{\mathsf{b}}}
% \def\vc{\ensuremath{\mathsf{c}}}
% \def\mul{\ensuremath{\mathsf{mul}}}
% \def\rem{\ensuremath{\mathsf{rem}}}
% \def\cat{\ensuremath{\mathsf{cat}}}
% \def\coeff{\ensuremath{\mathsf{coefficient}}}
% \def\mulmod{\ensuremath{\mathsf{mulmod}}}
% \def\x{\ensuremath{\mathbf{x}}}
% \def\uu{\ensuremath{\mathbf{U}}}
% \def\bb{\ensuremath{\mathbf{B}}}
% \def\bxi{\boldsymbol{\xi}}
% \def\bupsilon{\boldsymbol{\upsilon}}
% \def\bzeta{\boldsymbol{\zeta}}
% \def\blambda{\boldsymbol{\lambda}}
\def\euler{\ensuremath{\varphi}}

\newcommand{\D}{\Delta}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows}

\newcommand{\ph}{(\phi/\p)}
\newcommand{\m}{\mathfrak m}
\newcommand{\g}{\mathfrak g}
\newcommand{\be}{\mathfrak b}

\newcommand{\p}{\mathfrak p}
\newcommand{\h}{\mathfrak h}
\newcommand{\f}{\mathfrak f}
\newcommand{\q}{\mathfrak q}
\newcommand{\el}{\mathfrak l}
\newcommand{\B}{\mathfrak B}
\newcommand{\ef}{\mathcal F}


\setlength{\parindent}{0mm}





\title{On Elliptic Modules and Factoring Polynomials in Subquadratic Time}



\author[1]{Javad Doliskani}
\author[2]{Anand Kumar Narayanan}
\author[3]{\'Eric Schost}

\affil[1]{\small Institute for Quantum Computing, University of Waterloo}
\affil[2]{\small Computing and Mathematical Sciences, Caltech}
\affil[3]{\small Computer Science Department, University of Waterloo}

\date{}



\begin{document}
\maketitle

\begin{abstract}
	We present a novel randomized algorithm to factor polynomials over a finite field $\F_q$ of odd 
	characteristic using elliptic modules with complex multiplication. The main idea is to compute a
	lift of the Hasse invariant (modulo the polynomial $f(x) \in \F_q[x]$ to be factored) with 
	respect to a random elliptic module $\phi$ with complex multiplication. Factors of $f(x)$  
	supported on prime ideals with supersingular reduction at $\phi$ have vanishing Hasse invariant
	and can be separated from the rest. We also provide an implementation.
\end{abstract}



\section{Introduction}

Let $q$ be a power of a an odd prime $p$ and let $\F_q$ denote the finite field with $q$ elements. 
The univariate polynomial factorization problem over $\F_q$ is,
\begin{itemize}
	\item \textsc{Polynomial Factorization:} \textit{Given a monic $f(x) \in \mathbb{F}_q[x]$ of 
		degree $n$, write $f(x)$ as a product of its monic irreducible factors.}
\end{itemize}
Without loss of generality, we may assume that $f(x)$ is squarefree \cite{knu,yun}, that is, does 
not contain a square of an irreducible polynomial as a factor. Berlekamp showed that 
\textsc{Polynomial Factorization} can be solved in randomized polynomial time \cite{ber} and there 
is an extensive line of research \cite{cz,gs,ks,ku} with the best known runtime bound due to 
\cite{ku}.

The use of Drinfeld modules to factor polynomials over finite fields originated with Panchishkin 
and Potemine \cite{pp} whose algorithm was rediscovered by van der Heiden \cite{vdH}. These 
algorithms, along with the second author's Drinfeld module black box Berlekamp algorithm \cite{nar} 
are in spirit Drinfeld module analogues of Lenstra's elliptic curve method to factor integers 
\cite{len}. The Drinfeld module degree estimation algorithm of \cite{nar} uses Euler-Poincare 
charactersitics of Drinfeld modules to estimate the factor degrees in distinct degree 
factorization. A feature common to the aforementioned algorithms is their use of random Drinfeld 
modules, which typically don't have complex multiplication.

In this paper we take a different approach. We construct random rank $2$ Drinfeld modules $\phi$ 
with complex multiplication by an imaginary quadratic extension of the rational function field 
$\F_q(x)$  with class number $1$. At roughly half of the prime ideals $\p$ in $\F_q[x]$, $\phi$ 
has supersingular reduction. The Hasse invariant of $\phi$ at a prime ideal $\p$ vanishes if and 
only if $\phi$ has supersingular reduction at $\p$. A Drinfeld module analogue of Deligne's 
congruence, due to Gekeler \cite{gek}, allows us to compute a certain lift of Hasse invariants 
modulo the polynomial $f(x)$ we are attempting to factor. As a consequence, this lift vanishes 
exactly modulo the irreducible factors of $f(x)$ that correspond to the primes with supersingular 
reduction. In summary, we get to separate the irreducible factors corresponding to primes with 
supersingular reductions from those with ordinary reduction.

\paragraph{Complexity model.}
We will consider two different complexity models in our runtime analysis: \textit{Algebraic 
	model}, and \textit{Boolean model}. In the former we count the number of operations $+, \times, 
\div$ in the field $\F_q$ while in the latter we count the number of bit operations. The complexity 
upper bounds for polynomial multiplication and modular composition are denoted by $\MM(n), \CC(n)$ 
respectively. In the algebraic model we have $\MM(n) \in O(n\log(n)\log\log(n))$
\cite{Schonhage1971}, and $\CC(n) \in O(n^{(\omega+1)/2})$ \cite{BrKu78}, where $\omega$ comes 
from the cost $O(n^\omega)$ of square matrix multiplication. We can always take $\omega \le 2.37$ 
\cite{CoWi90} which gives $\CC(n) \in O(n^{1.69})$.

In the boolean model, the modular composition can be done in $n^{1 + o(1)}\log q^{1 + o(1)}$ bit 
operations \cite{ku}. In this case, the best polynomial factorization algorithm has the 
expected run time of $n^{3/2+o(1)} (\log q)^{1+o(1)}+n^{1+o(1)} (\log q)^{2+o(1)}$ bit operations. 
As to if the exponent $3/2$ in $n$ can be lowered remains an outstanding open question.


\paragraph{Main result.}
The crux of our algorithm is the computation of the Hasse invariant lift modulo $f(x)$. We exploit 
a recursive formula for the lift that arises in Gekeler's proof of a Drinfeld module variant of 
Deligne's congruence \cite{gek}. Our strategy is to first phrase the recurrence in matrix form with 
entries being polynomials modulo $f(x)$. We then observe that solving the recurrence amounts to 
computing the product of a carefully constructed sequence of matrices twited by the Frobenius 
action. The final step is to construct a polynomial with matrix coefficients, whose evaluations 
allow us to rapidly compute the aformentioned product. The evaluations are computed using a fast 
multipoint evaluation algorithm. Our main result can be summarized as:
\begin{theorem}
	\label{theorem:main}
	There exists a randomized algorithm for factoring a given polynomial $f(x)$ of degree $n$ over 
	$\F_q$ using expected
	\begin{itemize}
		\item $O(n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)})$ bit operations, or
		\item $O(n^{1.815}\log q)$ operations in $\F_q$.
	\end{itemize}
\end{theorem}


The paper is organized as follows. In Section \ref{drinfeld_section}, Drinfeld modules are 
introduced and the general algorithmic strategy is outlined with emphasis on the role played by 
Hasse invariants and Deligne's congruence. In Section \ref{sec:hasse}, our algorithm for computing 
the Hasse invariant lift is presented. A polynomials factorization algorithm is presented in 
Section \ref{sec:poly-fac}. Finally, in Section \ref{sec:impl}, an implementation and an example is 
provided.
 
 
 
 
%####################################################

\section{Drinfeld modules}

Let $A = \F_q[x]$ be the ring of univariate polynomials over the finite field $\F_q$ where $q$ is a 
prime power. Let $L/\F_q$ be a field with an $\F_q$-algebra homomorphism $\gamma: A \rightarrow 
L$. Let $\tau: \F_q \rightarrow \F_q$ be the Frobenius automorphism and let $L\{\tau\}$ be the 
\textit{skew-polynomial} ring defined by the action $\tau f = f^q\tau$ for all $f \in L$. Given an 
integer $r > 0$, a Drinfeld module of rank $r$ over $L$ is a morphism
\begin{equation}
\label{equ:Drinfeld}
	\begin{array}{rrll}
		\phi : & A & \longrightarrow & L\{\tau\} \\
		& x & \longmapsto & a_0 + a_1\tau + \cdots + a_r\tau^r	
	\end{array}
\end{equation}
with $a_0 = \gamma(x)$ and $a_r \ne 0$. 




\subsection{Elliptic modules}
\label{drinfeld_section}

An \textit{elliptic module} is a rank-2 Drinfeld module, obtained by setting $r = 2$ in 
\eqref{equ:Drinfeld}. In this paper, we consider elliptic modules over $\F_q(x)$, i.e. $L = 
\F_q(x)$, the field of fractions of $A$. In particular, $\phi$ will always be given as the ring 
homomorphisms
\[
\begin{array}{rrll}
	\phi : & \F_q[x] & \longrightarrow & \F_q(x)\ang{\tau} \\
	& x & \longmapsto & x + g_\phi \tau + \Delta_\phi \tau^2	
\end{array}
\]
for some $g_\phi \in \F_q[x]$ and nonzero $\Delta_\phi \in \F_q[x]$. Unless otherwise noted, a 
Drinfeld module over $\F_q(x)$ will mean an elliptic module as above. 

For a prime ideal $\p \subset \F_q[x]$, if $\Delta_\phi$ is nonzero modulo $\p$, then the reduction 
$\phi / \p = \phi \otimes \F_q[x] / \p$ of $\phi$ at $\p$ is defined as the ring homomorphism
\[
\begin{array}{rrll}
	\phi / \p : & \F_q[x] & \longrightarrow & (\F_\p/f) \ang{\tau} \\
	& x & \longmapsto & x + (g_\phi \bmod \p) \tau + (\Delta_\phi \bmod \p) \tau^.
\end{array}
\]
The image of $a \in \F_q[x]$ under $\phi/\p$ is denoted by $(\phi/\p)_a$. Even if $\Delta_{\phi}$ 
is zero modulo $\p$, one could still obtain the reduction $(\phi/\p)$ of $\phi$ at $\p$ through
minimal models of $\phi$; see \cite{gek1}. We refrain from addressing this case since it will not 
be required. For a nonzero ideal $\f \subset \F_q[x]$, let $\deg(\f)$ denote the degree of its 
monic generator.


\subsection{Hasse invariants and Deligne's congruence}

Let $\phi$ be an elliptic module as above and let $\p \in \F_q[x]$ be a prime no deviding  
$\Delta_\phi$. The \textit{Hasse invariant} $h_{\phi,\p} \in \F_q[x]/\p$ of $\phi$ at $\p$ is the 
coefficient of $\tau^{\deg(\p)}$ in the expansion 
\[ \ph_\p = \sum_{i=0}^{2\deg(\p)} h_i \tau^i \in (\F_{q}[x]/\p)\{\tau\}. \]
The elliptic module $\phi$ has supersingular reduction at $\p$ if and only if $h_{\phi, \p}$ 
vanishes $\bmod ~\p$ \cite{gos}. Otherwise, $\phi$ is said to have ordinary reduction at $\p$. When 
$\phi$ is fixed, we call $\p$ supersingular or ordinary with respect to $\phi$.

Recursively define a sequence $(r_{\phi,k})_{k \in \mathbb{N}}$ in $\F_q[x]^\mathbb{N}$ as 
$r_{\phi,0}:=1$, $r_{\phi,1}:=g_\phi$ and for $m>1$,
\begin{equation}
\label{eisenstein_recurrence}
	r_{\phi,m} := g_\phi^{q^{m-1}}r_{\phi,m-1} - (x^{q^{m-1}}-x)\D_\phi^{q^{m-2}} r_{\phi,m-2} \in 
	\F_q[x].
\end{equation}
Gekeler \cite[Eq 3.6, Prop 3.7]{gek} showed that $r_{\phi,m}$ is the value of the normalized 
Eisenstein series of weight $q^{m}-1$ on $\phi$ and established Deligne's congruence for elliptic 
modules. That is, for any $\p$ of degree $k \geq 1$ with $\Delta_\phi \neq 0 \bmod \p$, we have
\begin{equation}
\label{deligne_congruence}
	h_{\phi, \p}(x) = r_{\phi,k} \pmod{\p}.
\end{equation}
Hence, $r_{\phi,k}$ is in a sense a lift to $\F_q[x]$ of all the Hasse invariants of $\phi$ at 
primes of degree $k$. In particular, if $\phi$ has supersingular reduction at a $\p$ of degree $k$, 
that is, $h_{\phi, \p} = 0$, then by Deligne's congruence we have $r_{\phi,k} = 0 \bmod \p$. From 
the recurrence \eqref{eisenstein_recurrence}, it follows that $r_{\phi,k+1} = 0 \bmod \p$, since 
$\p$ divides $x^{q^k} - x$. Plugging $r_{\phi,k} = r_{\phi,k+1} = 0 \bmod \p$  into the 
recurrence \eqref{eisenstein_recurrence} yields
\begin{equation}
\label{supersingular_zero}
	r_{\phi,j} = 0 \pmod{\p}, ~ \forall~j \ge k.
\end{equation}
On the other hand, if $\phi$ has ordinary reduction at $f$, then \cite[Lemma~2.3]{cor}
\begin{equation}
\label{supersingular_nonzero}
	r_{\phi,j} \neq 0 \pmod{\p}, ~ \forall~j \ge k.
\end{equation}
This suggests that we could use an elliptic module $\phi$ in a polynomial factorization algorithm 
by separating supersingular primes from ordinary ones. For most elliptic modules, the density of 
supersingular primes is too small for this to work. However, for a special class, namely elliptic 
modules with complex multiplication, the density of supersingular primes is $1/2$. 




\subsection{Elliptic modules with complex multiplication}
\label{sec:elliptic-CM}

An elliptic module $\phi$ is said to have complex multiplication by an imaginary quadratic 
extension $L/\F_q(x)$ if $\End_{\F_q(x)}(\phi)\otimes_{\F_q[x]} \F_q(x) \cong L$. Here, $L$ is 
imaginary if the prime $(1/x) \in \F_q(x)$ at infinity does not split in $L$. For a $\phi$ with 
complex multiplication by $L$, a prime $\p$ that is unramified in $L$ is supersingular if and
only if $\p$ is inert in $L$.

This suggests the following strategy to factor a monic square free polynomial $f(x) \in \F_q[x]$. 
Suppose $f(x)$ factors into monic irreducible polynomials as $f(x) = \prod_i p_i(x)$. Pick an 
elliptic module $\phi$ with complex multiplication by some imaginary quadratic extension 
$L/\F_q(x)$. Compute $r_{\phi,k}(x) \bmod f$ for some $k \le \deg(f)$. By equations 
\eqref{supersingular_zero} and \eqref{supersingular_nonzero}, 
\begin{equation}
\label{equ:fact-sep}
	\gcd(r_{\phi,k} \bmod f, f) = \prod_{\substack{(p_i) \text{ inert in } L \\ \deg(p_i) \le k}} 
	p_i
\end{equation}
is a factor of $f$. Since for every degree, roughly half the primes of that degree are inert in 
$L$, the factorization thus obtained is likely to be nontrivial.


 
%####################################################
 

\section{Efficient computation of the Hasse invariant lift}
\label{sec:hasse}

In this section, we devise an efficient algorithm to compute the Hasse invariant lift. We let $\K = 
\F_q[x]/f(x)$ and define $\xi$ as the image of $x$ in $\K$. The recursion  
\eqref{eisenstein_recurrence} for computing $r_{\phi,n}(x)$ can be written as
\[
\begin{bmatrix}
	r_{\phi,k - 1} \\
	r_{\phi,k} \\
\end{bmatrix} = 
\begin{bmatrix}
	0 & 1 \\
	-[k - 1]\Delta^{q^{k - 2}} & g^{q^{k - 1}}
\end{bmatrix}
\begin{bmatrix}
	r_{\phi,k - 2} \\
	r_{\phi,k - 1} \\
\end{bmatrix}.
\]
where $[k - 1]:=\xi^{q^{k - 1}}-\xi$. Define the following sequence of matrices in $M_2(\K)$:
\[
A_k :=
\begin{bmatrix}
	0 & 1 \\
	-[k - 1]\Delta^{q^{k - 2}} & g^{q^{k - 1}}
\end{bmatrix}.
\]
Then we have
\[
\begin{bmatrix}
	r_{\phi,k - 1} \\
	r_{\phi,k} \\
\end{bmatrix}
= A_kA_{k - 1} \cdots A_2
\begin{bmatrix}
	r_{\phi,0} \\
	r_{\phi,1} \\
\end{bmatrix}.
\]
Our goal is to compute the product 
\[B_n := A_nA_{n - 1} \cdots A_2 ~ \in M_2(\K)\]
for then we can read off $r_{\phi,n}$ from $B_n[r_{\phi,0} ~ r_{\phi,1}]^T$. Extend the  
$q^{th}$-power Frobenius map $\tau: \K \to \K$ to the polynomial ring $M_2(\K)[Y]$ by leaving $Y$ 
fixed and acting on the coefficient matrices entry-wise. Let
\[
\mathcal{A} := 
\begin{bmatrix}
	0 & 1 \\
	-\tau(\xi)\Delta & \tau(g)
\end{bmatrix}
+
\begin{bmatrix}
	0 & 0 \\
	\Delta & 0
\end{bmatrix} Y ~ \in M_2(\K)[Y].
\]
For any $\mathcal{M} \in M_2(\K)[Y]$ and any $\zeta \in \K$, let $\mathcal{M}(\zeta)$ denote the 
image of $\mathcal{M}$ under the substitution 
\[Y \longmapsto 
\begin{bmatrix}
	\zeta & 0 \\
	0 & \zeta
\end{bmatrix}.
\]
Then, for any $k \ge 1$, we have $A_k = \tau^{k - 2}(\mathcal{A})(\xi)$. Let $\ell := \lceil 
n^\beta \rceil$, $m := \lfloor n / \ell \rfloor$ and define $\mathcal{B} := 
\tau^{\ell-1}(\mathcal{A}) \cdots \tau(\mathcal{A}) \mathcal{A}$. It follows from the above that 
$\mathcal{B}(\xi) = A_{\ell+1}A_{\ell - 2} \cdots A_2$. More generally, using the fact that for all 
$i, j$
\[A_{i + j + 2} = \tau^{i + j}(\mathcal{A})(\xi) = \tau^j\Big(\tau^i(\mathcal{A})(\tau^{-j}\xi) 
\Big),\]
we deduce for all $i \ge 1$ that $\tau^{i}\mathcal{B}(\tau^{-i}\xi) = A_{i + \ell+1} \cdots A_{i + 
3} A_{i + 2}$. In particular, $B_n$ can be computed as the product of the following matrices, 
\[
\mathcal{B} (\xi), \tau^{\ell}\mathcal{B}(\tau^{-\ell}\xi), \dots, \tau^{m \ell}\mathcal{B}( 
\tau^{-m \ell}\xi).
\]
This suggest Algorithm \ref{alg:hasse-inv} for computing $B_n$.
\begin{algorithm}[H]
	\caption{Compute Hasse invariant}
	\label{alg:hasse-inv}
	\begin{algorithmic}[1]
		\REQUIRE A degree $n$ polynomial $f \in \F_q[x]$ and the coefficients $\Delta, g \pmod{f}$ 
		of an elliptic module $\phi$.
		\ENSURE The $n$-th Hasse invariant lift $r_{\phi,n}(x) \pmod{f}$.
		\STATE Let $\ell := \lceil n^\beta \rceil$, and let $m := \lceil n / \ell \rceil$
		\STATE\label{step:hasse-2}
		Compute $\mathcal{B} = \tau^{\ell-1}(\mathcal{A}) \cdots \tau(\mathcal{A}) \mathcal{A}$
		\STATE\label{step:hasse-3}
		Compute $\xi_i = \tau^{-i\ell}(\xi)$ for $0 \le i \le m$
		\STATE\label{step:hasse-4}
		Compute $\beta_i = \mathcal{B}(\xi_i)$ for $0 \le i \le m$
		\STATE\label{step:hasse-5}
		Compute $t_i = \tau^{i\ell}(\beta_i)$ for $0 \le i \le m$
		\STATE\label{step:hasse-6} 
		Compute $B_n = t_m t_{m - 1} \cdots t_0$ 
		\RETURN\label{step:hasse-7}
		$r_{\phi,n} = B_n[r_{\phi,0} ~ r_{\phi,1}]^T$.
	\end{algorithmic}
\end{algorithm}
The correctness of the algorithm follows from the preceding remarks. The next two subsections 
analyze its complexity in both boolean and algebraic models.


\subsection{Complexity in an algebraic model}

First we need a lemma from \cite{ks} for efficient simultaneous modular composition, which we 
include here for convenience.
\begin{lemma}[\cite{ks}]
	\label{lemma:ks}
	Given a polynomials $f \in \K[x]$ of degree $n$ over an arbitrary field $\K$, and polynomials 
	$g_1, \dots, g_k, h \in \K[x]$ of degree less than $n$, where $k = O(n)$, we can compute 
	\[ g_1(h) \bmod f, \dots, g_k(h) \bmod f \]
	using $O(n^{(\omega + 1) / 2} k^{(\omega - 1) / 2})$ operations in $\K$.
\end{lemma}
The complexity of algorithm \ref{alg:hasse-inv} is analyzed in the following theorem.
\begin{theorem}
	\label{theo:hasse-inv}
	Algorithm \ref{alg:hasse-inv} runs in
	\[O(n^{(\omega + 1) / 2 + (1 - \beta)(\omega - 1) / 2} + n^{1 + \beta + o(1)}\log q)\] 
	operations in $\F_q$, where $\omega$ is the matrix multiplication exponent. Taking $\omega 
	\approx	2.375$ and $\beta \approx 0.815$, the complexity is $O(n^{1.815}\log q)$ operations in 
	$\F_q$.
\end{theorem}
\begin{proof}
	Step \ref{step:hasse-2} is done using $\ell$ successive applications of the Frobenius and 
	multiplying the results. Here we do the Frobenius using binary-powering. The cost is 
	$O(\ell\MM(n)\log q + \MM(\ell n)) = O(n^{1 + \beta + o(1)}\log q)$ operations in $\F_q$.
	
	Step \ref{step:hasse-3} is computed as follows. First we compute $g = \tau^{m\ell}(\xi)$ by 
	computing $\tau(\xi)$ using binary-powering and then doing $\log (m\ell)$ modular polynomial 
	compositions. This takes $O(\CC(n)\log n + \MM(n)\log q)$ operations in $\F_q$. Now we find $f 
	\in \K$ such that 
	\[f^{q^{m\ell}} = \tau^{m\ell}(f) = f(g) = \xi.\]
	In other words we find $f = \tau^{-m\ell}(\xi)$. This can be done using transposed modular 
	composition with cost dominated by previous steps, see \cite{DeDoSc2014} for more details. So 
	we have $\xi_m = f$, and other $\xi_i$ for $i < m$ can be computed using Lemma \ref{lemma:ks}. 
	This takes $O(n^{(\omega + 1) / 2}n^{(1 - \beta)(\omega - 1) / 2}) = O(n^{(\omega + 1) / 2 + (1 
	- \beta)(\omega - 1) / 2})$ operations in $\F_q$.
	
	Step \ref{step:hasse-4} can be done using multipoint evaluation \cite{vzGG}. We are evaluating 
	a polynomial of degree at most $\ell$ at $m$ points. This takes $O((\ell / m + \log m) 
	\MM(m\ell)) = O(n^{2\beta + o(1)})$ operations in $\F_q$.
	
	Step \ref{step:hasse-5} is done as follows. Assume we have the polynomials $h_i = 
	\tau^{i\ell}(\xi)$, $1 \le i \le m$ from the previous steps. One can compute these polynomials, 
	if necessary, at the cost of $O(n^{(\omega + 1) / 2 + (1 - \beta)(\omega - 1) / 2})$ using 
	Lemma \ref{lemma:ks}. Computing a value $\tau^{s\ell}(\beta_i)$ is equivalent to computing the 
	modular composition $\beta_i(h_s)$. Consider the list $\beta_1, \beta_2, \dots, \beta_m$. One 
	can produce all the powers $\tau^{\ell}(\beta_1), \dots, \tau^{m\ell}(\beta_m)$ only using 
	composition with $h_1, h_2, h_{2^2}, \dots, h_{2^d}$ where $d = \lfloor \log m \rfloor$. More 
	precisely, all the $\beta_i$ with the $k$-th bit of the binary representation of $i$ equal to 
	'1' are composed with $h_{2^k}$. There are $m / 2$ of these $\beta_i$. Therefore, $O(\log m)$ 
	applications of Lemma \ref{lemma:ks} at the cost of $O(n^{(\omega + 1) / 2 + (1 - \beta)(\omega 
	- 1) / 2})$ gives the final result. 
	
	Step \ref{step:hasse-6} is done using $O(m\MM(n)) = O(n^{2 - \beta + o(1)})$ operations in 
	$\F_q$ which is dominated by the rest.
\end{proof}



\subsection{Complexity in a boolean model}

Since modular composition can be done in $O(n^{1 + \varepsilon}\log q^{1 + o(1)})$ bit operations 
in a boolean model, we take a different approach to analyze Algorithm \ref{alg:hasse-inv}. First,  
we set $\beta = 1/2$ so that $\ell = O(n^{1/2})$. Step \ref{step:hasse-2} is done using a simple 
recursion which performs alternate applications of the Frobenius and multiplications. More 
precisely, starting from the matrix $\mathcal{A}$, assume at the $i$-th step we have computed 
$\tau^{\lfloor i/2 \rfloor}(\mathcal{A}) \tau^{\lfloor i/2 \rfloor-1} \ldots \tau(\mathcal{A}) 
\mathcal{A}$. It now takes one application of the $\tau^{\lfloor i/2 \rfloor}$ map and a few 
multiplications in $M_2(\K)[Y]$ to compute $\tau^{i-1}(\mathcal{A}) \tau^{i-2} \ldots 
\tau(\mathcal{A}) \mathcal{A}$. The map $\tau^{\lfloor i \rfloor}$ itself is computed from
$\tau^{\lfloor i/2 \rfloor}$ the same way. The whole recursion takes
\[ n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)} \]
bit operations. 

Step \ref{step:hasse-3} can be done using $m$ modular compositions at the cost of $n^{3/2+o(1)} 
(\log q)^{1+o(1)}$ bit operations. Step \ref{step:hasse-4} can be done using multipoint evaluation 
\cite{vzGG} at the cost of $n^{1+o(1)} (\log q)^{2+o(1)}$ bit operations. Step \ref{step:hasse-5} 
costs the same as Step \ref{step:hasse-3}. 

Finally, step \ref{step:hasse-6}, \ref{step:hasse-7} can be done using $n^{3/2+o(1)} (\log 
q)^{1+o(1)}$ bit operations. In summary, we have proven 
\begin{theorem}
	\label{theo:hasse-inv}
	Algorithm \ref{alg:hasse-inv} runs in 
	\[O(n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)})\]
	bit operations.
\end{theorem}



 
%####################################################
 

\section{A polynomial factoring algorithm}
\label{sec:poly-fac}

The efficient computation of the Hasse invariant lift in Section \ref{sec:hasse} allows us to 
efficiently factor polynomials as follows. Given a polynomial $f \in \F_q[x]$ of degree $n$, we 
compute the $\lceil n / 2 \rceil$-th Hasse lift $r_{\phi, \lceil n / 2 \rceil} \bmod f$. Then 
according to \eqref{equ:fact-sep}, the factors of $f$ that are inert in an imaginary quadratic 
extension $L/\F_q(x)$ can be separated by computing a $\gcd$. If the elliptic module $\phi$ has 
complex multiplication, the probability of obtaining a nontrivial factor of $f$ in this way is 
close to $1/2$. We first need to construct elliptic modules with complex multiplication.

\paragraph{Elliptic modules with complex multiplication}
Our strategy is to pick an $a \in \F_q$ at random and construct a elliptic module $\phi$ with 
complex multiplication by the imaginary quadratic extension $\F_q(x)(\sqrt{d(x)})$ of discriminant 
$d(x):=x-a$. From \cite{dor}, the elliptic module $\phi^\prime$ with 
\[ g_{\phi^\prime}(x):=\sqrt{d(x)}+\left(\sqrt{d(x)}\right)^q, \D_{\phi^\prime}(x) := 1 \]
has complex multiplication by $\F_q(x)(\sqrt{d(x)})$.
However, $\phi^\prime$ has the disadvantage of not being defined over $\F_q[x]$ since 
$g_{\phi^\prime}(x) \notin \F_q[x]$.
We construct an alternate $\phi$, that is isomorphic to $\phi^\prime$ but defined over $\F_q[x]$. 
The $J$-invariant \cite{gek} of $\phi^\prime$ is 
\[ J_{\phi^\prime}(x) := \frac{g_{\phi^\prime}(x)^{q+1}}{\D_{\phi^\prime}(x)} = 
d(x)^{\frac{q+1}{2}}\left(1+d(x)^{\frac{q-1}{2}}\right)^{q+1}. \]
With the knowledge that two elliptic modules with the same $J$-invariant are isomorphic, we 
construct the elliptic module $\phi$ satisfying 
\[ g_\phi(x)^{q+1} = (J_{\phi^\prime}(x))^2, \D_{\phi}(x)= J_{\phi^\prime}(x)\] thereby ensuring 
$J_{\phi}(x)=J_{\phi^\prime}(x)$. Further, this assures that $\phi$ is defined over $\F_q[x]$ since
\[g_\phi(x) = d(x)\left(1 + d(x)^{\frac{q-1}{2}}\right)^2, \quad  \D_\phi(x) = d(x)^{\frac{q + 
1}{2}}\left(1 + d(x)^{\frac{q-1}{2}}\right)^{q+1}. \]
In summary, $\phi$ has complex multiplication by $\F_q(x)(\sqrt{d(x)})$ and is defined over $A$.



\subsection{Polynomial factorization}
We now state our randomized algorithm to factor polynomials over finite fields using elliptic 
modules with complex multiplication.

\begin{algorithm}[H]
	\caption{Polynomial factorization}
	\label{factoring_algorithm}
	\begin{algorithmic}[1]
		\REQUIRE Monic squarefree $f \in \F_q[x]$ of degree $n$
		\ENSURE The irreducible factors of $f$
		\STATE If $f$ is irreducible then print $f$ and return
		\STATE\label{step:fac-2}
		Remove the linear factors of $f$ and output them
		\STATE\label{step:fac-3}
		Pick $a \in \F_q$ uniformly at random and compute \\
		$d(x) := x - a \mod f$ \\
		$g_\phi(x) := d(x)(1+d(x)^{\frac{q-1}{2}})^2 \mod f$ \\
		$\Delta_\phi(x) := d(x)^{\frac{q+1}{2}}(1+d(x)^{\frac{q-1}{2}})^{q+1} \mod f$
		\STATE\label{step:fac-4}
		Compute $r_{\phi, \lceil n / 2 \rceil} \bmod f$ as in recurrence 
		\eqref{eisenstein_recurrence} (that is, the $\lceil n / 2 \rceil$-th Hasse invariant lift 
		with respect to the elliptic module $\phi$ with coefficients $g_\phi, \Delta_\phi$, 
		computed modulo $f$)
		\STATE\label{step:fac-split}
		Compute $f_1 := \gcd(r_{\phi, \lceil n / 2 \rceil}, f)$ and recursively factor $f_1$ and 
		$f/f_1$.
	\end{algorithmic}
\end{algorithm}

The irreducibility test in Step $1$ can be performed in $O(\CC(n)\log n + \MM(n)\log q)$ operations 
in $\F_q$ \cite{vzGG}, or $O(n^{1+o(1)} (\log q)^{2+o(1)})$ bit operations. In Step 
\ref{step:fac-2}, all the linear factors of $f(x)$ are found and removed using a root finding 
algorithm. It takes $O(\MM(n)\log n \log(nq))$ operations in $\F_q$ \cite{vzGG}, or $O(n^{1+o(1)} 
(\log q)^{2+o(1)})$ bit operations.

In Step \ref{step:fac-3}, we choose $a \in \F_q$ at random and construct a Drinfeld module $\phi$ 
with complex multiplication by $\F_q(x)(\sqrt{x-a})$. The primes that divide $\D_\phi(x)$ are 
precisely $\{(x-b),  b \in \F_q, \sqrt{b-a} \notin \F_q\} \cup \{(d)\}$. We might run into issues 
of bad reduction if the polynomial $f$ to be factored had roots. It is to prevent this, we 
performed root finding in Step \ref{step:fac-2}.

In Step \ref{step:fac-4}, the Hasse invariant lift is computed at the cost of 
\[O(n^{(\omega + 1) / 2 + (1 - \beta)(\omega - 1) / 2} + n^{1 + \beta + o(1)}\log q)\]
operations in $\F_q$ or 
\[ O(n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)}) \]
bit operations. 
 
As mentioned in Subsection \ref{sec:elliptic-CM}, $\gcd(r_{\phi,k}, f)$ is the product of all 
degree at most $k$ irreducible factors of $f$ that are supersingular with respect to $\phi$. Thus 
our algorithm separates the irreducible factors supported at the supersingular primes from those 
supported at the ordinary primes. In the following, we show that for an elliptic module chosen  
randomly as in Step \ref{step:fac-3}, the splitting of $f$ in Step \ref{step:fac-split} is random 
enough to ensure that the recursion depth is $O(\log n)$. Since the algorithm is dominated by Step 
\ref{step:fac-4}, this will prove Theorem \ref{theorem:main}.

\paragraph{On the splitting of factors}
We prove in Lemma \ref{splitting_lemma} that any two distinct factors of $f$ of the same degree are 
neither both supersingular nor both ordinary with probability $1/2$. This ensures that the 
splitting into supersingular and ordinary factors in Step \ref{step:fac-split} of Algorithm 
\ref{factoring_algorithm} is random enough that the recursion depth of our algorithm is logarithmic 
in $n$. For the lemma to apply to the algorithm, we need to assume $\sqrt{q} \ge n$.  The 
assumption $\sqrt{q} \ge  n$ can be made without loss of generality in theory. For if $\sqrt{q} < 
n$, we might choose to factor over a slightly larger field $\F_{q^\prime}$ where $q^\prime$ is the 
smallest power of $q$ such that $\sqrt{q^\prime} > n$ and still recover the factorization over 
$\F_q$ (c.f. \cite[Remark 3.2]{nar}). Further, the running times are only affected by logarithmic 
factors. In practice, we recommend running Algorithm \ref{factoring_algorithm} as is and take the 
Lemma \ref{splitting_lemma} as strong evidence for the recursion depth to be logarithmic in $n$.
\begin{lemma}
\label{splitting_lemma}
	Let $p_1,p_2 \in \F_q[x]$ be distinct monic irreducible polynomials of degree $k$ where $1 < k 
	\le \sqrt{q}$. Let $\phi$ be an elliptic module with complex multiplication by the imaginary 
	quadratic extension $\F_q(x)(\sqrt{x-a})$ where $a \in \F_q$ is chosen at random. With 
	probability close to $1/2$, exactly one of $(p_1)$ or $(p_2)$ is supersingular with respect to 
	$\phi$.
\end{lemma}
\begin{proof}
	Let $F = \F_q(x)$. Since $k > 1$, none of $(p_1), (p_2)$ ramify in $F(\sqrt{x-a})$. Therefore, 
	the probability that exactly one of $(p_1), (p_2)$ is supersingular with respect to $\phi$ is 
	the same as the probability that exactly one of them splits in $F(\sqrt{x-a})/F$.
	
	For $i = 0, 1$, let $K_i:=F(\alpha_i)$ be the hyperelliptic extension of $F$ obtained by 
	adjoining a root $\alpha_i$ of $y^2-p_i$. By quadratic reciprocity over function fields 
	\cite{carlitz1932}, since $p_1$ and $p_2$ have the same degree, exactly one of $(p_1), (p_2)$ 
	splits in $F(\sqrt{x-a})$ if and only if $x-a$ is split in exactly one of $K_1, K_2$. That is, 
	$(x-a)$ is neither completely split nor completely inert in the composite $K_1K_2$. Since $p_1, 
	p_2$ are distinct, $K_1$ and $K_2$ are linearly disjoint over $F$. Further, $K_1K_2$ is Galois 
	over $F$ with 
	\[ \gal(K_1K_2/F) \cong \gal(K_1/F) \times \gal(K_2/F) \cong \Z/2\Z \oplus 
	\Z/2\Z. \]  
	For $(x-a)$ to be neither totally split nor totally inert, the Artin symbol 
	\[ ((x-a), K_1K_2/F) \in \gal(K_1K_2/F) \]
	has to be either $(0,1)$ or $(1,0)$ under the isomorphism $\gal(K_1K_2/F) \cong \Z/2\Z \oplus 
	\Z/2\Z$. Applying Chebotarev's density theorem, the number $N$ of degree one primes $\{(x-a), a 
	\in \F_q\}$ that are neither totally inert nor totally split in $K_1K_2$ is bounded by 
	\[ \left|N - \frac{q}{2} \right| \le 2 g(K_1K_2)\sqrt{q} \]
	where $g(K_1K_2)$ is the genus of $K_1K_2$. By the Riemann-Hurwitz genus formula, $g(K_1K_2) = 
	k-1 \le \sqrt{q}/2$. Hence when $a \in \F_q$ is chosen at random, $(x-a)$ is neither totally 
	inert nor totally split in $K_1K_2$ with probability close to $1/2$. 
\end{proof}




%####################################################


\section{Implementation and example}
\label{sec:impl}

We have implemented Algorithms \ref{alg:hasse-inv}, \ref{factoring_algorithm} in C++ using the NTL 
library \cite{shoup2001ntl}. The implementation source code can be found at 
\url{https://github.com/javad-doliskani/supersingular_drinfeld_factoring}. After running the 
algorithm on 100 random input polynomials, we observed that the splitting $\gcd(r_{\phi, \lceil n / 
2 \rceil}, f)$ is almost always nontrivial when $f$ is reducible. This confirms the behavior 
expected from theory. Also we observed that, in practice, one does not need to impose the condition 
$\sqrt{q} \ge n$ for splitting a polynomial of degree $n$ over $\F_q$. This remedies the need for 
working in an auxiliary extension over $\F_q$. To show the behavior of the algorithm in practice we 
finish this section with an example output of Algorithm \ref{factoring_algorithm} on input a small 
degree polynomial.

\paragraph{Example}
Consider the randomly selected polynomial 
\[ f(x) = 2 + 6x + 5x^3 + 4x^4 + 6x^5 + 2x^7 + 3x^8 + 3x^9 + x^{10} \]
in $\F_7[x]$. The algorithm starts by checking for linear factors, which $f$ has none. So, in the 
next step it generates the random supersingular elliptic module parameterized by
\[
\begin{array}{rll}
	d(x) & = & 1 + x, \\
	g_\phi(x) & = & 4 + 2x + 5x^2 + x^3 + 2x^4 + x^7, \\
	\Delta_\phi(x) & = & 3 + 3x + 5x^3 + x^4 + x^5 + x^6 + 6x^7 + 5x^8 + 5x^9.
\end{array}
\]
This means $\phi$ has complex multiplication by the imaginary quadratic extension $\F_7(x)(\sqrt{x 
+ 1})$ of $\F_7(x)$. After computing the $5$-th Hasse lift $r_{\phi, 5}$, it finds $f_1 = 
\gcd(r_{\phi, 5}, f) = 1 + 4x + x^2 + 4x^3 + x^4$. This is the product of the factors of $f$ that 
are supuersingular with respect to $\phi$. Now, $f_1$ does not pass the irreducibility check, so 
the process is repeated for $f_1$. The next randomly generated supersingular elliptic module is
\[
\begin{array}{rll}
	d(x) & = & 5 + x, \\
	g_\phi(x) & = & 2 + x^2 + 6x^3, \\
	\Delta_\phi(x) & = & 6 + x + 5x^2 + 5x^3.
\end{array}
\]
Now, $f_{11} = \gcd(r_{\phi, 2}, f_1) = 4 + 6x + x^2$, and $f_{12} = f_1 / f_{11} = 2 + 5x + x^2$ 
which are both irreducible. Again, this means that $f_{11}$ is supuersingular and $f_{12}$ is 
ordinary with respect to $\phi$. Finally, $f / f_1 = 2 + 5x + 6x^2 + 3x^3 + 6x^4 + 6x^5 + x^6$ 
which is also irreducible. The complete factorization of $f$ is then
\[ f(x) = (4 + 6x + x^2)(2 + 5x + x^2)(2 + 5x + 6x^2 + 3x^3 + 6x^4 + 6x^5 + x^6).\]


\bibliographystyle{plain}
\bibliography{references}
\end{document}



