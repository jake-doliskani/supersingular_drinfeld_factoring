\documentclass{article}

\usepackage[margin = 1in]{geometry}
\usepackage{graphicx}              
\usepackage{amsmath}               
\usepackage{amsfonts}              
\usepackage{amsthm}                
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{url}
\usepackage{hyperref}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{authblk}





\hypersetup{
	unicode=true,
	colorlinks=true,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black,
	pdfstartview={FitH},
}

% theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{example}[theorem]{Example}
\newtheorem*{remark}{Remark}
\newtheorem{note}[theorem]{Note}


\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\algsetup{linenodelimiter=.}





\newcommand{\wrt}{\vdash} 
\newcommand{\ang}[1]{\langle#1\rangle}
\newcommand{\abs}[1]{\left\vert#1\right\vert}
\newcommand{\dual}[1]{\overline{#1}}
\newcommand{\mapsfrom}{\ensuremath{\reflectbox{$\mapsto$}}}
\newcommand{\tildO}{\tilde{O}}
% roman numerals
\newcommand{\romnum}[1]{\romannumeral #1}
\newcommand{\Romnum}[1]{\uppercase\expandafter{\romannumeral #1}}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\comment}[2][Note]{\textcolor{green}{(#1): #2}}

\DeclareMathOperator{\fieldchar}{char} % characteristic of a field
\DeclareMathOperator{\ringofend}{End} % endomorphism ring
\DeclareMathOperator{\trace}{Tr} % finite field trace
\DeclareMathOperator{\gal}{Gal} % Galois group
\DeclareMathOperator{\order}{ord} % order of an element
\DeclareMathOperator{\lcm}{lcm} % least common multiple
\DeclareMathOperator{\divisor}{div} % divisor on a curve
\DeclareMathOperator{\supp}{supp} % support of a divisor
\DeclareMathOperator{\norm}{N} % norm
\DeclareMathOperator{\Res}{Res}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\minpoly}{minpoly}
\DeclareMathOperator{\loglog}{loglog}
\DeclareMathOperator{\rev}{rev}

\def\Q{\ensuremath{\mathbb{Q}}}
\def\N{\ensuremath{\mathbb{N}}}
\def\R{\ensuremath{\mathbb{R}}}
\def\Z{\ensuremath{\mathbb{Z}}}
\def\F{\ensuremath{\mathbb{F}}}
% \def\H{\ensuremath{\mathbb{H}}}
\def\K{\ensuremath{\mathbb{K}}}
% \def\L{\ensuremath{\mathbb{L}}}
% \def\A{\ensuremath{\mathbb{A}}}
% \def\B{\ensuremath{\mathbb{B}}}
\def\MM{\ensuremath{\mathsf{M}}}
\def\MMM{\ensuremath{\mathsf{MM}}}
% \def\MC{\ensuremath{\mathsf{C}}}
% \def\PC{\ensuremath{\mathsf{PC}}}
% \def\II{\ensuremath{\mathsf{I}}}
% \def\QQ{\ensuremath{\mathsf{Q}}}
\def\CC{\ensuremath{\mathsf{C}}}
% \def\RR{\ensuremath{\mathsf{R}}}
% \def\AA{\ensuremath{\mathsf{A}}}
% \def\va{\ensuremath{\mathsf{a}}}
% \def\vy{\ensuremath{\mathsf{y}}}
% \def\vu{\ensuremath{\mathsf{u}}}
% \def\vb{\ensuremath{\mathsf{b}}}
% \def\vc{\ensuremath{\mathsf{c}}}
% \def\mul{\ensuremath{\mathsf{mul}}}
% \def\rem{\ensuremath{\mathsf{rem}}}
% \def\cat{\ensuremath{\mathsf{cat}}}
% \def\coeff{\ensuremath{\mathsf{coefficient}}}
% \def\mulmod{\ensuremath{\mathsf{mulmod}}}
% \def\x{\ensuremath{\mathbf{x}}}
% \def\uu{\ensuremath{\mathbf{U}}}
% \def\bb{\ensuremath{\mathbf{B}}}
% \def\bxi{\boldsymbol{\xi}}
% \def\bupsilon{\boldsymbol{\upsilon}}
% \def\bzeta{\boldsymbol{\zeta}}
% \def\blambda{\boldsymbol{\lambda}}
\def\euler{\ensuremath{\varphi}}

\newcommand{\D}{\Delta}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows}

\newcommand{\ph}{(\phi/\p)}
\newcommand{\m}{\mathfrak m}
\newcommand{\g}{\mathfrak g}
\newcommand{\be}{\mathfrak b}

\newcommand{\p}{\mathfrak p}
\newcommand{\h}{\mathfrak h}
\newcommand{\f}{\mathfrak f}
\newcommand{\q}{\mathfrak q}
\newcommand{\el}{\mathfrak l}
\newcommand{\B}{\mathfrak B}
\newcommand{\ef}{\mathcal F}


\setlength{\parindent}{0mm}





\title{Drinfeld Modules with Complex Multiplication, Hasse Invariants and Factoring Polynomials over Finite Fields}



\author[1]{Javad Doliskani}
\author[2]{Anand Kumar Narayanan}
\author[3]{\'Eric Schost}

\affil[1]{\small Institute for Quantum Computing, University of Waterloo}
\affil[2]{\small Computing and Mathematical Sciences, Caltech}
\affil[3]{\small Computer Science Department, University of Waterloo}

\date{}



\begin{document}
\maketitle

\begin{abstract}
We present a novel randomized algorithm to factor polynomials over a finite field $\F_q$ of odd characteristic using rank $2$ Drinfeld modules with complex multiplication. The main idea is to compute a lift of the Hasse invariant (modulo the polynomial $f(x) \in \F_q[x]$ to be factored) with respect to a random Drinfeld module $\phi$ with complex multiplication. Factors of $f(x)$ supported on prime ideals with supersingular reduction at $\phi$ have vanishing Hasse invariant and can be separated from the rest.\\ \\


% The crux of our algorithm is computing the Hasse invariant lift.
 Incorporating a Drinfeld module analogue of Deligne's congruence, we devise an intricate method to 
 compute the Hasse invariant lift, which turns out to be the crux of our algorithm. The resulting 
 expected runtime of $n^{3/2+o(1)} (\log q)^{1+o(1)}+n^{1+o(1)} (\log q)^{2+o(1)}$ to factor 
 polynomials of degree $n$ over $\F_q$ matches the fastest previously known algorithm, the 
 Kedlaya-Umans implementation of the Kaltofen-Shoup algorithm. In comparison, our algorithm has the 
 distinction of not requiring separate distinct degree and equal degree factorization phases, 
 potentially leading to a faster implementation. We augment our theoretical results with a 
 subquadratic implementation of our algorithm that from preliminary experimentation appears to the 
 fastest way to factor polynomials over finite fields.

% A Drinfeld module analogue of Deligne's congruence plays a key role in computing the Hasse 
%invariant lift. We devise an intricate algorithm to compute the Hasse invariant lift yielding an 
%expected runtime of $n^{3/2+o(1)} (\log q)^{1+o(1)}+n^{1+o(1)} (\log q)^{2+o(1)}$ to factor 
%polynomials of degree $n$ over $\F_q$. This matches the fastest previously known algorithm, the 
%Kedlaya-Umans implementation of the Kaltofen-Shoup algorithm. Unlike the Kaltofen\\ \\
 
%We present two algorithms based on this idea. The first algorithm  chooses Drinfeld modules with complex multiplication at random and has a quadratic expected run time. The second is a deterministic algorithm with $O(\sqrt{p})$ run time dependence on the characteristic $p$ of $\F_q$.
\end{abstract}

\section{Introduction}
%\subsection{Randomized Polynomial Factorization over Finite Fields}
Let $q$ be a power of a an odd prime $p$ and let $\F_q$ denote the finite field with $q$ elements. 
The univariate polynomial factorization problem over $\F_q$ is,
\begin{itemize}
 \item \textsc{Polynomial Factorization:} \textit{Given a monic $f(x) \in \mathbb{F}_q[x]$ of 
 degree $n$, write $f(x)$ as a product of its monic irreducible factors.}
\end{itemize}


Without loss of generality, we may assume that $f(x)$ is squarefree \cite{knu,yun}, that is, does 
not contain a square of an irreducible polynomial as a factor. Berlekamp showed that 
\textsc{Polynomial Factorization} can be solved in randomized polynomial time \cite{ber} and there 
is an extensive line of research \cite{cz,gs,ks,ku} with the best known bound due to \cite{ku}. \\

The use of Drinfeld modules to factor polynomials over finite fields originated with Panchishkin 
and Potemine \cite{pp} whose algorithm was rediscovered by van der Heiden \cite{vdH}. These 
algorithms, along with the second author's Drinfeld module black box Berlekamp algorithm \cite{nar} 
are in spirit Drinfeld module analogues of Lenstra's elliptic curve method to factor integers 
\cite{len}. The Drinfeld module degree estimation algorithm of \cite{nar} uses Euler-Poincare 
charactersitics of Drinfeld modules to estimate the factor degrees in distinct degree 
factorization. A feature common to the aforementioned algorithms is their use of random Drinfeld 
modules, which typically don't have complex multiplication. \\


In this paper we take a different approach. We construct random rank $2$ Drinfeld modules $\phi$ 
with complex multiplication by an imaginary quadratic extension of the rational function field 
$\F_q(x)$  with class number $1$. At roughly half of the prime ideals $\p$ in $\F_q[x]$, $\phi$ 
has supersingular reduction. The Hasse invariant of $\phi$ at a prime ideal $\p$ vanishes if and 
only if $\phi$ has supersingular reduction at $\p$. A Drinfeld module analogue of Deligne's 
congruence, due to Gekeler \cite{gek}, allows us to compute a certain lift of Hasse invariants 
modulo the polynomial $f(x)$ we are attempting to factor. As a consequence, this lift vanishes 
exactly modulo the irreducible factors of $f(x)$ that correspond to the primes with supersingular 
reduction. In summary, we get to separate the irreducible factors corresponding to primes with 
supersingular reductions from those with ordinary reduction.


\paragraph{Complexit model.}
We will consider two different complexity models in our runtime analysis: \textit{Algebraic 
model}, and \textit{Boolean model}. In the former we count the number of operations $+, \times, 
\div$ in the field $\F_q$ while in the latter we count the number of bit operations. The complexity 
upper bounds for polynomial multiplication and modular composition are denoted by $\MM(n), \CC(n)$ 
respectively. In the algebraic model we have $\MM(n) \in O(n\log(n)\log\log(n))$
\cite{Schonhage1971}, and $\CC(n) \in O(n^{(\omega+1)/2})$ \cite{BrKu78}, where $\omega$ comes 
from the cost $O(n^\omega)$ of square matrix multiplication. We can always take $\omega \le 2.37$ 
\cite{CoWi90} which gives $\CC(n) \in O(n^{1.69})$.

In the boolean model, the modular composition can be done in $O(n^{1 + \varepsilon}\log q^{1 + 
o(1)})$ bit operations \cite{ku}. In this case, the best polynomial factorization algorithm has the 
expected run time of $n^{3/2+o(1)} (\log q)^{1+o(1)}+n^{1+o(1)} (\log q)^{2+o(1)}$ bit operations. 
As to if the exponent $3/2$ in $n$ can be lowered remains an outstanding open question.


\paragraph{Main result.}
The crux of our algorithm is the computation of the Hasse invariant lift modulo $f(x)$. We exploit 
a recursive formula for the lift that arises in Gekeler's proof of a Drinfeld module variant of 
Deligne's congruence \cite{gek}. Our strategy is to first phrase the recurrence in matrix form with 
entries being polynomials modulo $f(x)$. We then observe that solving the recurrence amounts to 
computing the product of a carefully constructed sequence of matrices twited by the Frobenius 
action. The final step is to construct a polynomial with matrix coefficients, whose evaluations 
allow us to rapidly compute the aformentioned product. The evaluations are computed using a fast 
multipoint evaluation algorithm. Our main result can be summarized as:

\begin{theorem}
	\label{theorem:main}
	Given a polynomial $f(x)$ of degree $n$ over $\F_q$, there exits a probabilistic algorithm for 
	factoring $f$ using
	\begin{itemize}
		\item $O(n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)})$ bit operations, or
		\item $O(n^{1.815}\log q)$ operations in $\F_q$.
	\end{itemize}
\end{theorem}


The paper is organized as follows. In \S~\ref{drinfeld_section}, Drinfeld modules are introduced 
and the general algorithmic strategy is outlined with emphasis on the role played by Hasse 
invariants and Deligne's congruence. In \S~\ref{randomized_section}, a high level description of 
our algorithm and its rigorous analysis using function field arithmetic is presented. Fast 
computation of the Hasse invariant lift, analysis of the complexity of the algorithm and its 
practical implications are in \S~\ref{sec:hasse}. 
 
 

\section{Rank-2 Drinfeld Modules}\label{drinfeld_section}
 Let $A=\F_q[x]$ denote the polynomial ring in the indeterminate $x$ and let $K$ be a field with a 
 non zero ring homomorphism $\gamma:A \rightarrow K$. Necessarily, $K$ contains $\F_q$ as a 
 subfield. Fix an algebraic closure $\bar{K}$ of $K$ and let $\tau: \bar{K} \longrightarrow 
 \bar{K}$ denote the $q^{th}$ power Frobenius endomorphism. The ring of endomorphisms of the 
 additive group scheme $\mathbb{G}_a$ over $K$ can be identified with the skew polynomial ring 
 $K\langle \tau \rangle$ where $\tau$ satisfies the commutation rule $\forall u \in K, \tau u = u^q 
 \tau$.
A rank-2 Drinfeld module over $K$ is (the $A$-module structure on $\mathbb{G}_a$ given by) a ring homomorphism
$$\phi : A \longrightarrow K\langle \tau \rangle$$ 
$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x \longmapsto \gamma(x) + g_\phi \tau + \Delta_\phi \tau^2$$
for some $g_\phi \in K$ and $\Delta_\phi \in K^\times$. For $a \in A$, let $\phi_a$ denote the image of $a$ under $\phi$. We will concern ourselves primarily with rank $2$ Drinfeld modules and unless otherwise noted, a Drinfeld module will mean a rank $2$ Drinfeld module.\\ \\
%To every $A$-algebra $L$ over $\bar{K}$, the Drinfeld module $\phi$ endows a new $A$-module structure (which, we denote by $\phi(L)$) through the $A$-action $$\forall f \in L, \forall a \in A, a*f = \phi_a(f).$$  
%For every $A$-algebra homomorphism $\rho:L \longrightarrow L$,  $\forall a\in A$ and $\forall f \in L$, $\rho(\phi(f)) = \phi(\rho(f))$. Thus $\rho$, when thought of as a map from $\phi(L) \longrightarrow \phi(L)$, is an $A$-module homomorphism. For every direct product $L \times L^\prime$ of $A$-algebras over $\bar{K}$, we hence have the corresponding direct sum of $A$-modules $$\phi(L \times L^\prime) \cong \phi(L) \oplus \phi(L^\prime).$$
Henceforth, we restrict our attention to Drinfeld modules $\phi:A \longrightarrow \F_q(x)\langle\tau\rangle$ over $\F_q(x)$ (with $\gamma : A \rightarrow \F_q(x)$ being the inclusion (identity), $g_\phi(x)\in A$ and $\Delta_\phi(x)\in A^\times$) and their reductions.\\ \\
%For a proper ideal $\f \subset A$, let $\F_\f$ denote $A/\f$. 
For a prime ideal $\p \subset A$, if $\Delta_\phi$ is non zero modulo $\p$, then the reduction $\phi/\p := \phi \otimes A/\p$ of $\phi$ at $\p$ is defined through the ring homomorphism $$\phi/\p : A \longrightarrow \F_\p\langle \tau \rangle$$ $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ t \longmapsto t + (g_\phi \mod \p) \tau + (\Delta_\phi\mod\p) \tau^2$$
and the image of $a \in A$ under $\phi/\p$ is denoted by $(\phi/\p)_a$. Even if $\Delta_{\phi}$ is zero modulo $\p$, one can still obtain the reduction $(\phi/\p)$ of $\phi$ at $\p$ through minimal models of $\phi$ (c.f. \cite{gek1}). We refrain from addressing this case since our algorithms do not require it.\\ \\
%As before, the Drinfeld module $\phi/\p$ endows a new $A$-module structure (denoted by $\ph(L)$) to every $A$-algebra $L$ over the algebraic closure of $\F_\p$ through the $A$-action $$\forall f \in L, \forall a \in A, a*f = \ph_a(f)$$ and for every direct product $L \times L^\prime$ of $A$-algebras over the algebraic closure of $\F_\p$, $$\ph(L \times L^\prime) \cong \ph(L) \oplus \ph(L^\prime).$$
%Further, for every $A$-algebra $L$ over the algebraic closure of $\F_\p$, $\phi(L) \cong \ph(L)$.\\ \\
For $f(x) \in A$, denote by $(f(x))$ the ideal generated by $f(x)$ and by $\deg(f)$ the degree of 
$f(x)$. For a non zero ideal $\f \subset A$, let $\deg(\f)$ denote the degree of its monic 
generator. For $f(x),g(x) \in A$, by $\gcd(f(x),g(x))$ we mean the monic generator of the ideal 
generated by $f(x)$ and $g(x)$. Abusing notation, by $\gcd(\alpha,f(x))$ for some $f(x) \in A, 
\alpha \in A/(f(x))$ we really mean the gcd of $f(x)$ and a lift of $\alpha$ to $A$.



\section{Hasse Invariants and Deligne's Congruence}
Let $\p \subset A$ be a prime not dividing $\Delta_\phi$. Let $p \in A$ be the monic generator of $\p$. The Hasse invariant $h_{\phi,\p}(x) \in A$ of $\phi$ at $\p$ is the coefficient of $\tau^{\deg(p)}$ in the expansion $$\ph_p  = \sum_{i=0}^{2\deg(p)} h_i(\ph)(x) \tau^i \in A\langle \tau \rangle.$$
%and it is related to the Frobenius trace by
%\begin{equation}\label{hasse_trace}
%a_{\phi,\p} = \epsilon_{\phi,\p}H_{\phi,\p}.
%\end{equation}
The Drinfeld module $\phi$ has supersingular reduction at $\p$ if and only if $\p$ divides $(h_{\phi,\p}(x))$ \cite{gos}. If the choice of $\phi$ is clear from context, we will call $\p$ supersingular.\\ \\
Recursively define a sequence $(r_{\phi,k}(x) \in A,k \in \mathbb{N})$ as $r_{\phi,0}(x):=1$, $r_{\phi,1}(x):=g_\phi$ and for $m>1$,
\begin{equation}\label{eisenstein_recurrence}
r_{\phi,m}(x) := \left(g_\phi(x)\right)^{q^{m-1}}r_{\phi,m-1}(x) - (x^{q^{m-1}}-x) \left(\D_\phi(x)\right)^{q^{m-2}} r_{\phi,m-2}(x) \in A.
\end{equation}
Gekeler (c.f.\cite{gek}[Eq 3.6, Prop 3.7]) showed that $r_{\phi,m}(x)$ is the value of the normalized Eisenstein series of weight $q^{m}-1$ on $\phi$ and established Deligne's congruence for Drinfeld modules, which ascertains for any $\p$ of degree $k \geq 1$ with $\Delta_\phi(x) \neq 0 \mod \p$ that 
\begin{equation}\label{deligne_congruence}
 h_{\phi,\p}(x) = r_{\phi,k}(x) \mod \p.
\end{equation}
Hence $r_{\phi,k}(x)$ is in a sense a lift to $A$ of all the Hasse invariants of $\phi$ at primes of degree $k$.\\ \\
In particular, if $\phi$ has supersingular reduction at a $\p$ of degree $k$, then $h_{\phi,\p}(x)=0$. By Deligne's congruence, $r_{\phi,k}(x) = 0 \mod \p$. From the recurrence \ref{eisenstein_recurrence}, it follows that $r_{\phi,k+1}(x) = 0 \mod \p$ since $\p$ divides $x^{q^k}-x$. Plugging $r_{\phi,k}(x) = r_{\phi,k+1}(x)= 0 \mod \p$ into the recurrence \ref{eisenstein_recurrence} yields  
\begin{equation}\label{supersingular_zero}
 r_{\phi,j}(x) = 0 \mod \p , \forall j \geq k.
\end{equation}
Likewise, if $\phi$ does not have supersingular reduction at a $\p$ of degree $k$, then by \cite{cor}[Lem 2.3]
\begin{equation}\label{supersingular_nonzero}
 r_{\phi,j}(x) \neq 0 \mod \p , \forall j \geq k.
\end{equation}
This suggests that we could use a Drineld module $\phi$ in a polynomial factorization algorithm to 
separate supersingular primes from those that are not. For most Drinfeld modules, the density of 
supersingular primes is too small for this to work. However, for a special class, Drinfeld modules 
with complex multiplication, the density of supersingular primes is $1/2$. 


\section{Drinfeld Modules with Complex Multiplication}\label{randomized_section}
A Drinfeld module $\phi$ is said to have complex multiplication by an imaginary quadratic extension $L/\F_q(x)$ if $End_{\F_q(x)}(\phi)\otimes_A \F_q(x) \cong L$. By imaginary, we mean the prime $(1/x)$ at infinity in $\F_q(x)$ does not split in $L$. For a $\phi$ with complex multiplication by $L/\F_q(x)$, a prime $\p$ that is unramified in $L/\F_q(x)$  is supersingular if and only if $\p$ is inert in $L/\F_q(x)$.\\ \\
This suggests the following  strategy to factor a monic square free polynomial $f(x) \in A$. Say 
$f(x)$ factors into monic irreducibles as $f(x) = \prod_i p_i(x)$. Pick a Drinfeld module $\phi$ 
with complex multiplication by some imaginary quadratic extension $L/\F_q(x)$. Compute 
$r_{\phi,k}(x) \mod (f(x))$ for some $k \leq \deg(f)$. By equations \ref{supersingular_zero} and 
\ref{supersingular_nonzero}, $$\gcd(r_{\phi,k}(x) \mod (f(x)), f(x)) = \prod_{(p_i)\ inert\ in\ 
L/\F_q(x), \deg(p_i)\leq k}p_i(x)$$ is a factor of $f$. Since for every degree, roughly half the 
primes of that degree are inert in $L/\F_q(x)$, the factorization  thus obtained is likely to be 
non trivial. 


\section{Randomized Polynomial Factorization using Drinfeld Modules with Complex Multiplication}
\subsection{Constructing Drinfeld Modules with Complex 
Multiplication}\label{drinfeld_construction_subsection}

Our strategy is to pick an $a \in \F_q$ at random and construct a Drinfeld module $\phi$ with complex multiplication by the imaginary quadratic extension $\F_q(x)(\sqrt{d(x)})$ of discriminant $d(x):=x-a$. From \cite{dor}, the Drinfeld module $\phi^\prime$ with $$g_{\phi^\prime}(x):=\sqrt{d(x)}+\left(\sqrt{d(x)}\right)^q, \D_{\phi^\prime}(x) := 1$$ has complex multiplication by $\F_q(x)(\sqrt{d(x)})$.\\ \\
However, $\phi^\prime$ has the disadvantage of not being defined over $A$ since $g_{\phi^\prime}(x) \notin A$.\\ \\
We construct an alternate $\phi$, that is isomorphic to $\phi^\prime$ but defined over $A$. The $J$-invariant \cite{gek} of $\phi^\prime$ is $$J_{\phi^\prime}(x) := \frac{g_{\phi^\prime}(x)^{q+1}}{\D_{\phi^\prime}(x)} = d(x)^{\frac{q+1}{2}}\left(1+d(x)^{\frac{q-1}{2}}\right)^{q+1}.$$
With the knowledge that two Drinfeld modules with the same $J$-invariant are isomorphic, we construct the Drinfeld module $\phi$ satisfying $$g_\phi(x)^{q+1} = (J_{\phi^\prime}(x))^2, \D_{\phi}(x)= J_{\phi^\prime}(x)$$ thereby ensuring $$J_{\phi}(x)=J_{\phi^\prime}(x).$$ Further, this assures that $\phi$ is defined over $A$ since

$$g_\phi(x):=d(x)(1+d(x)^{\frac{q-1}{2}}),\D_\phi(x):=d(x)^{\frac{q+1}{2}}(1+d(x)^{\frac{q-1}{2}})^{q+1}.$$
In summary, $\phi$ has complex multiplication by $\F_q(x)(\sqrt{d(x)})$) and is defined over $A$.
\subsection{Polynomial Factorization using Drinfeld Modules with Complex Multiplication}
We now state our randomized algorithm to factor polynomials over finite fields using Drinfeld modules with complex multiplication. Curiously, it can be stated and implemented with no reference to Drinfeld modules.


\begin{algorithm}[H]
	\caption{Polynomial factorization}
	\label{factoring_algorithm}
	\begin{algorithmic}[1]
		\REQUIRE Monic squarefree $f(x) \in \F_q[x]$ of degree $n$
		\ENSURE The irreducible factors of $f(x)$
		\STATE If $f(x)$ is irreducible then print $f(x)$ and return.
		\STATE If $f(x)$ has roots in $\F_q$, find and remove the roots.
		%\STATE Let $\K = \F_q[x] / f$
		\STATE Pick $a \in \F_q$ uniformly at random and compute \\ % the following elements in $\K$ \\
		$d(x) := x-a \mod f(x)$. \\
		$g_\phi(x) := d(x)(1+d(x)^{\frac{q-1}{2}}) \mod f(x)$. \\
		$\Delta_\phi(x) := d(x)^{\frac{q+1}{2}}(1+d(x)^{\frac{q-1}{2}})^{q+1} \mod f(x)$ .
		\STATE Compute $r_{\phi,n}(x) \mod f(x)$ as in recurrence \ref{eisenstein_recurrence} (that is, the $n$-th Hasse invariant lift with respect to the Drinfeld module $\phi$ with coefficients $g_\phi, \Delta_\phi$, computed modulo $f(x)$).
		\STATE Compute $f_1(x) := \gcd(r_{\phi,n}(x), f(x))$ and recursively factor $f_1(x)$ and $f(x)/f_1(x)$.
	\end{algorithmic}
\end{algorithm}

\begin{remark}
	In Step $4$, we may compute $r_{\phi,k} \mod f(x)$ for some $k\geq n$ instead of $r_{\phi,k} \mod f(x)$. As is evident from the forthcoming paragraphs, the rest of the algorithm would run identically. For instance, it might be convenient in practice to chose $k$ to be the smallest power of $2$ that is at least $n$.
\end{remark}


The irreducibility test in Step $1$ can be performed in $O(\CC(n)\log n + \MM(n)\log q)$ operations 
in $\F_q$ \cite{vzGG}, or $O(n^{1+o(1)} (\log q)^{2+o(1)})$ bit operations. In Step $2$, all the 
linear factors of $f(x)$ are found and removed using a root finding algorithm. It takes 
$O(\MM(n)\log n \log(nq))$ operations in $\F_q$ \cite{vzGG}, or $O(n^{1+o(1)} (\log q)^{2+o(1)})$ 
bit operations. \\

 In Step $3$, we choose $a \in \F_q$ at random and construct a Drinfeld module $\phi$ with complex 
 multiplication by $\F_q(x)(\sqrt{x-a})$. The primes that divide $\D_\phi(x)$ are precisely 
 $\{(x-b),  b \in \F_q, \sqrt{b-a} \notin \F_q\} \cup \{(d(x))\}$. We might run into issues of bad 
 reduction if the polynomial $f(x)$ to be factored had roots. It is to prevent this, we performed 
 root finding in Step $2$. \\

 In Step $4$, from the recurrence \ref{eisenstein_recurrence}, we indeed compute the $n^{th}$ Hasse 
 invariant lift $r_{\phi,n}(x)$ modulo $f(x)$. By Deligne's congruence \ref{deligne_congruence}, a 
 degree $k$ monic irreducible factor $p(x)$ of $f(x)$ divides $r_k(x)$ if and only if $(p(x))$ is 
 supersingular with respect to $\phi$. In particular, $\gcd(r_{\phi,k}(x),f(x))$ is the product of 
 all degree $k$ irreducible factors of $f(x)$ that are supersingular with respect to $\phi$. 
 Further, by equations \ref{supersingular_zero} and \ref{supersingular_nonzero}, 
 $\gcd(r_{\phi,k}(x),f(x))$ is the product of all degree at most $k$ irreducible factors of $f(x)$ 
 that are supersingular with respect to $\phi$. In particular, $(f_1(x) =) 
 \gcd(r_{\phi,k}(x),f(x))$ is the product of irreducible factors of $f(x)$ that are supersingular 
 with respect to $\phi$. Thus our algorithm separates the irreducible factors supported at the 
 supersingular primes from those supported at the ordinary primes. All that remains to argue is 
 that for a Drinfeld module chosen as randomly in Algorithm \ref{factoring_algorithm}, this split 
 is random enough to ensure that the recursion depth is logarithmic in $n$.\\ 

%Hence at iteration $k$ in Step $4$, by Deligne's congruence \ref{deligne_congruence}, a degree $k$ monic irreducible factor $p(x)$ of $f(x)$ divides $r_k(x)$ if and only if $(p(x))$ is supersingular with respect to $\phi$. In particular, $\gcd(r_k(x),f(x))$ is the product of all degree $k$ irreducible factors of $f(x)$ that are supersingular with respect to $\phi$. If there is only one such factor, we output it. Else, the product is multiplied to $f_{ss}(x)$ to be split recursively later. Likewise, at iteration $k$ in Step $4$, $\gcd(x^{q^k}-x,f(x))/\gcd(r_{k}(x),f(x))$ is the product of all degree $k$ irreducible factors of $f(x)$ that are ordinary with respect to $\phi$. If there is only one such factor, we output it. Else, the product is multiplied to $f_{or}(x)$ to be split recursively later.\\ 

 The following Lemma \ref{splitting_lemma} states that any two distinct factors of $f(x)$ of the 
 same degree are neither both supersingular nor both ordinary with probability $1/2$. This ensures 
 that the splitting into supersingular and ordinary factors in Step $4$ is random enough that the 
 recursion depth of our algorithm is logarithmic in $n$. For the lemma to apply to Algorithm 
 \ref{factoring_algorithm}, we need to assume $\sqrt{q} \geq n$.  
The assumption $\sqrt{q} \geq  n$ in Algorithm \ref{factoring_algorithm} can thankfully be made without loss of generality in theory. For if $\sqrt{q} < n$, we might choose to factor over a slightly larger field $\F_{q^\prime}$ where $q^\prime$ is the smallest power of $q$ such that $\sqrt{q^\prime} > n$ and still recover the factorization over $\F_q$ (c.f. \cite[Remark 3.2]{nar}). Further, the running times are only affected by logarithmic factors. In practice, we recommend running Algorithm \ref{factoring_algorithm} as is and take Lemma \ref{splitting_lemma} as strong evidence for the recursion depth to be logarithmic in $n$.


\begin{lemma}\label{splitting_lemma}
Let $p_1(x),p_2(x) \in A $ be two distinct monic irreducible polynomials of degree $k$ where $1<k \leq \sqrt{q}$. Let $\phi$ be a Drinfeld module with complex multiplication by the imaginary quadratic extension $\F_q(x)(\sqrt{x-a})$ where $a \in \F_q$ is chosen at random. With probability close to $1/2$, exactly one of $(p_1(x))$ or $(p_2(x))$ is supersingular with respect to $\phi$.
\end{lemma}
\begin{proof}
Since $k > 1$ neither $(p_1(x))$ nor $(p_2(x))$ ramify in $\F_q(x)(\sqrt{x-a})$. Hence, the probability that exactly one of $(p_1(x))$ or $(p_2(x))$ is supersingular with respect to $\phi$ is precisely the probability that exactly one of $(p_1),(p_2)$ splits in $\F_q(x)(\sqrt{x-a})/\F_q(x)$.\\ \\
%That is, exactly one of $(p_1),(p_2)$ splits in $\F_q(t)(\sqrt{d})/\F_q(t)$.
For $i\in\{0,1\}$, let $K_i:=\F_q(x)(\alpha_i)$ be the hyperelliptic extension of $\F_q(t)$ obtained by adjoining a root $\alpha_i$ of $y^2-p_i(x)$. By quadratic reciprocity over function fields \cite{car}, since $p_1(x)$ and $p_2(x)$ have the same degree, exactly one of $(p_1(x)),(p_2(x))$ splits in $\F_q(x)(\sqrt{x-a})$ if and only if $x-a$ is split in exactly one of $K_1,K_2$. That is, $(x-a)$ is neither completely split nor completely inert in the composite $K_1K_2$. Since $p_1(x)$ and $p_2(x)$ are distinct, $K_1$ and $K_2$ are linearly disjoint over $\F_q(x)$. Further, $K_1K_2$ is Galois over $\F_q(t)$ with $$Gal(K_1K_2/\F_q(x)) \cong Gal(K_1/\F_q(x)) \times Gal(K_2/\F_q(x)) \cong \Z/2\Z \oplus \Z/2\Z.$$  For $(x-a)$ to be neither totally split nor totally inert, the Artin symbol $$((x-a),K_1K_2/\F_q(x)) \in Gal(K_1K_2/\F_q(x))$$ has to be either $(0,1)$ or $(1,0)$ under the isomorphism $Gal(K_1K_2/\F_q(x)) \cong \Z/2\Z \oplus \Z/2\Z$. Applying Chebotarev's density theorem, the number $N$ of degree one primes $\{(x-a),a\in \F_q\}$ that are neither totally inert nor totally split in $K_1K_2$ is bounded by 
$$ \left|N - \frac{q}{2} \right| \leq 2 g(K_1K_2)\sqrt{q}$$
where $g(K_1K_2)$ is the genus of $K_1K_2$. By the Riemann-Hurwitz genus formula, $g(K_1K_2) = k-1 \leq \sqrt{q}/2$. Hence when $a \in \F_q$ is chosen at random, $(x-a)$ is neither totally inert nor totally split in $K_1K_2$ with probability close to $1/2$. 
\end{proof}
In summary, we have thus proven that Algorithm \ref{factoring_algorithm} is correct and that it has 
expected recursion depth logarithmic in $n$. Further, the bottleneck is Step $4$, the computation 
of the Hasse invariant lift. A naive computation relying on recurrence \ref{eisenstein_recurrence} 
would lead to a runtime dependence quadratic in $n$. In the forthcoming section we describe a 
deterministic algorithm Algorithm \ref{alg:hasse-inv} to compute the Hasse invariant lift with 
runtime subquadratic in $n$. Incorporating Algorithm \ref{alg:hasse-inv} in Algorithm 
\ref{factoring_algorithm} thus leads to Theorem \ref{theorem:main}.



\section{Efficient computation of the Hasse invariant lift}
\label{sec:hasse}

In this section we devise an efficient algorithm to compute the Hasse invariant lift. We let $\K = \F_q[x]/f(x)$ and define $\xi$ as the image of $x$ in $\K$. The recursion \ref{eisenstein_recurrence} for computing $r_{\phi,n}(x)$ can be written as
\[
\begin{bmatrix}
r_{\phi,k - 1} \\
r_{\phi,k} \\
\end{bmatrix} = 
\begin{bmatrix}
0 & 1 \\
-[k - 1]\Delta^{q^{k - 2}} & g^{q^{k - 1}}
\end{bmatrix}
\begin{bmatrix}
r_{\phi,k - 2} \\
r_{\phi,k - 1} \\
\end{bmatrix}.
\]
where $[k - 1]:=\xi^{q^{k - 1}}-\xi$. Define the following sequence of matrices in 
$\mathscr{M}_2(\K)$:
\[
A_k :=\begin{bmatrix}
0 & 1 \\
-[k - 1]\Delta^{q^{k - 2}} & g^{q^{k - 1}}
\end{bmatrix}.
\]
Then we have
\[
\begin{bmatrix}
r_{\phi,k - 1} \\
r_{\phi,k} \\
\end{bmatrix} = 
A_kA_{k - 1} \cdots A_2
\begin{bmatrix}
r_{\phi,0} \\
r_{\phi,1} \\
\end{bmatrix}.
\]
Our goal is to compute the product 
\[B_n := A_nA_{n - 1} \cdots A_2 ~ \in ~ \mathscr{M}(\K)\]
for then we can read off $r_{\phi,n}$ from $B_n\begin{bmatrix}
r_{\phi,0} \\
r_{\phi,1} \\
\end{bmatrix}.$ 
%for a given positive integer $m$. Although the following algorithm works for any $m$, we set $m = 
%n$ for the sake of simplicity, specially when analyzing the runtime complexity. 
%Define the linear map $\tau: \K \to \K$ given by $\tau(f) = f^q$ for any $f$ in $\K$. We can extend the action of $\tau$ to the polynomial ring $\mathscr{M}_2(\K)[Y]$ by leaving $Y$ fixed and acting on the coefficient matrices entry-wise.
Extend the $\F_q$-linear $q^{th}$-power Frobenius map $\tau: \K \to \K$ to the polynomial ring $\mathscr{M}_2(\K)[Y]$ by leaving $Y$ fixed and acting on the coefficient matrices entry-wise.
Let
\[
\mathcal{A} := 
\begin{bmatrix}
0 & 1 \\
-\tau(\xi)\Delta & \tau(g)
\end{bmatrix}
+
\begin{bmatrix}
0 & 0 \\
\Delta & 0
\end{bmatrix} Y ~ \in ~ \mathscr{M}_2(\K)[Y].
\]
For a $\mathcal{M} \in \mathscr{M}_2(\K)[Y]$ and a $\zeta \in \K$, let $\mathcal{M}(\zeta)$ denote the image of $\mathcal{M}$ under the substitution 
\[Y \longmapsto 
\begin{bmatrix}
	\zeta & 0 \\
	0 & \zeta
\end{bmatrix}.
\]
Then, for any $k \ge 1$, we have $$A_k = \tau^{k - 2}(\mathcal{A})(\xi).$$
Let $\ell := \lceil n^\beta \rceil$, $m := \lceil n / \ell \rceil$ and define 
\[\mathcal{B} := \tau^{\ell-1}(\mathcal{A}) \cdots \tau(\mathcal{A}) \mathcal{A}.\]
It follows from the above that 
\[\mathcal{B}(\xi) = A_{\ell-1}A_{\ell - 2} \cdots A_2.\]
More generally, using the fact that for all $i, j$
\[A_{i + j} = \tau^{i + j}(\mathcal{A})(\xi) = \tau^j\Big(\tau^i(\mathcal{A})\big( \tau^{-j}(\xi)\big)\Big),\]
we deduce for all $i \ge 1$ that 
\[\tau^{i}\Big(\mathcal{B} \big( \tau^{-i}(\xi)\big) \Big) = A_{i + \ell-1} \cdots A_{i + 1}A_i.\]

In particular, $B_n$ can be computed as the product of the following values, 
\[
\mathcal{B} \big(\xi\big), \tau^{\ell}\Big(\mathcal{B} \big( \tau^{-\ell}(\xi)\big) \Big), \dots, 
\tau^{m \ell}\Big(\mathcal{B} \big( \tau^{-m \ell}(\xi)\big) \Big).
\]
This suggest Algorithm \ref{alg:hasse-inv} for computing $B_n$.

\begin{algorithm}[H]
	\caption{Compute Hasse invariant}
	\label{alg:hasse-inv}
	\begin{algorithmic}[1]
		\REQUIRE A degree $n$ polynomial $f(x)$ and the coefficients $\Delta(x), g(x)$ (modulo $f(x)$) of a Drinfeld module $\phi$.
		\ENSURE The $n$-th Hasse invariant lift $r_{\phi,n}(x)$ modulo $f(x)$.
		\STATE Let $\ell := \lceil n^\beta \rceil$, and let $m := \lceil n / \ell \rceil$
		\STATE\label{step:hasse-2}
		Compute $\mathcal{B} = \tau^{\ell-1}(\mathcal{A}) \cdots \tau(\mathcal{A}) \mathcal{A}$
		\STATE\label{step:hasse-3}
		For $0 \le i \le m$, \\
		compute $\xi_i = \tau^{-i\ell}(\xi)$
		\STATE\label{step:hasse-4}
		For $0 \le i \le m$, \\
		compute $\beta_i = \mathcal{B}(\xi_i)$
		\STATE\label{step:hasse-5}
		For $1 \le i \le m$ \\
		compute $t_i = \tau^{i\ell}(\beta_i)$
		\RETURN $r_{\phi,n}$, by reading off from $B_n$ computed as the product $t_0t_1 \cdots t_m$.
	\end{algorithmic}
\end{algorithm}

 The correctness of the algorithm follows from the preceding remarks. The next two subsections 
 analyze its complexity in both boolean and algebraic models.
 

\subsection{Complexity in an algebraic model}

In this subsection we prove the following:
\begin{theorem}
	\label{theo:hasse-inv}
	Algorithm \ref{alg:hasse-inv} runs in
	\[O(n^{(\omega + 1) / 2 + (1 - \beta)(\omega - 1) / 2} + n^{1 + \beta + o(1)}\log q)\] 
	operations in $\F_q$, where $\omega$ is the matrix multiplication exponent. Taking $\omega 
	\approx	2.375$ and $\beta \approx 0.815$, the above is $O(n^{1.815}\log q)$ operations in 
	$\F_q$.
\end{theorem}

\begin{proof}
Step \ref{step:hasse-2} is done using $\ell$ successive applications of the Frobenius and 
multiplying the results. Here we do the Frobenius using binary-powering. The cost is 
$O(\ell\MM(n)\log q + \MM(\ell n)) = O(n^{1 + \beta + o(1)}\log q)$ operations in $\F_q$.

Step \ref{step:hasse-3} is computed as follows. First we compute $g = \tau^{m\ell}(\xi)$ by 
computing $\tau(\xi)$ using binary-powering and then doing $\log (m\ell)$ modular polynomial compositions. This takes $O(\CC(n)\log n + \MM(n)\log q)$ operations in $\F_q$. Now we find $f \in \K$ such that \[f^{q^{m\ell}} = \tau^{m\ell}(f) = f(g) = \xi.\]
In other words we find $f = \tau^{-m\ell}(\xi)$. This can be done using transposed modular 
composition with cost dominated by previous steps, see \cite{DeDoSc2014} for more details. So we 
have $\xi_m = f$, and other $\xi_i$ for $i < m$ can be computed using \cite[Lemma 3]{ks}. This 
takes $O(n^{(\omega + 1) / 2}n^{(1 - \beta)(\omega - 1) / 2}) = O(n^{(\omega + 1) / 2 + (1 - 
\beta)(\omega - 1) / 2})$ operations in $\F_q$.

Step \ref{step:hasse-4} can be done using multipoint evaluation \cite{vzGG}. We are evaluating a 
polynomial of degree at most $\ell$ at $m$ points. This takes $O((\ell / m + \log m) \MM(m\ell)) = 
O(n^{2\beta + o(1)})$ operations in $\F_q$.

 Step \ref{step:hasse-5} is again done using \cite[Lemma 3]{ks} at the cost of $O(n^{(\omega + 1) / 
 2 + (1 - \beta)(\omega - 1) / 2})$ operations in $\F_q$. The cost of the product in the last step 
 is dominated by the rest. %All in all, this proves the complexity claim in Theorem 
 %\ref{theo:hasse-inv}.
\end{proof}


\subsection{Complexity in a boolean model}

In this subsection we set $\beta = 1/2$. Curiously, each of the steps \ref{step:hasse-2}, 
\ref{step:hasse-3}, \ref{step:hasse-4} and \ref{step:hasse-5} can each be performed in 
$n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)}$. time. We next briefly sketch 
how.\\ 
 
 Step \ref{step:hasse-2} is performed recursively. Given 
 $\tau^{\lfloor\ell/2\rfloor}(\alpha)\tau^{\lfloor\ell/2\rfloor-1}\ldots\tau(\alpha) \alpha$, it 
 takes one $\tau^{\lfloor\ell/2\rfloor}$ map (and a constant number of multiplications) in 
 $\mathscr{M}_2(\K)[Y]$ to compute $\tau^{\ell-1}(\alpha)\tau^{\ell-2}\ldots\tau(\alpha)\alpha$. 
 The $\tau^{\lfloor\ell/2\rfloor}$ power map is computed using the iterated Frobenius algorithm of 
 von zur Gathen and Shoup \cite{gs} implemented using fast modular composition \cite{ku}. Step 
 \ref{step:hasse-3} is performed using \cite[Lemma 3]{ks} implemented using fast modular 
 composition \cite{ku}. Step \ref{step:hasse-5} is nearly identical, except its performed over 
 $\mathscr{M}_2(\K)$. Step \ref{step:hasse-4} is performed using multipoint evaluation \cite{vzGG}. 
 In summary, we have proven 
 \begin{theorem}
 	\label{theo:hasse-inv}
 	Algorithm \ref{alg:hasse-inv} runs in 
 	\[O(n^{3/2+o(1)} (\log q)^{1+o(1)} + n^{1+o(1)} (\log q)^{2+o(1)})\]
 	bit operations.
 \end{theorem}



\bibliographystyle{plain}
\bibliography{references}
\end{document}



